@namespace Moth.AST
@classname MothParser
@accessibility public
@using Moth
@using Moth.AST.Node

script <ScriptAST> = _ nmspace:file_namespace statements:top_level* { new ScriptAST(nmspace, statements.ToList()) }

file_namespace <NamespaceNode> = "namespace" ws+ nmspace:namespace ';' { nmspace }

namespace <NamespaceNode> = "::" name:name child:namespace? { new NamespaceNode(name, child.Count == 1 ? child[0] : null) }

top_level <ITopDeclNode> = _ val:(<ITopDeclNode>
        import
        / func_decl
    ) _ { val }

import <ImportNode> = "with" ws+ nmspace:namespace ';' { new ImportNode(nmspace) }

method_decl <FuncDefNode> = isStatic:"static"? ws+ val:func_decl {
        {
            if (isStatic.Count > 0)
                val.IsStatic = true;
            
            return val;
        }
    }

//TODO: attrs and privacy need their whitespace to be required only if they are there
func_decl <FuncDefNode> =
    attrs:attribute* ws+
    privacy:privacy ws+
    "func" ws+
    name:name _ '(' _ par:param<0,,','> _ ')' _
    ret:type_ref _
    scope:(<ScopeNode?> scope / ';' { null }) {
        //TODO: support variadics
        new FuncDefNode(name, privacy, ret, par.ToList(), scope, false, false, attrs.ToList())
    }

privacy <PrivacyType> = p:(<string> "priv" / "pub")? {
        p.Count == 1
            ? p[0] == "pub"
                ? PrivacyType.Pub
                : PrivacyType.Priv
            : PrivacyType.Priv
    }

param <ParameterNode> = name:name _ type:type_ref { new ParameterNode(name, type) }

scope <ScopeNode> = '{' _ statements:expression<0,,';'> _ '}' { new ScopeNode(statements.ToList()) }

sub_expr <IExpressionNode> = '(' _ inner:expression _ ')' { inner }

expression <IExpressionNode> -memoize
    = scope
    / sub_expr
    / parent2:(<IExpressionNode> parent:expression _ '.' _ { parent })? name:name {
        new RefNode(name, parent2.Count == 1 ? parent2[0] : null)
    }
    / literal

//TODO: does this need to support complex expressions?
attribute <AttributeNode> = '@' name:name args2:(<IList<LiteralNode>> _ '(' _ args:literal<0,,','> _ ')' { args })? {
    new AttributeNode(name, args2.Count == 1 ? args2[0].ToList() : new List<LiteralNode>())
}

//TODO: strings and chars and... scientific notation?
literal <LiteralNode>
    = literal_int
    / literal_float

//TODO: template type ref
type_ref <ITypeRefNode> -memoize
    = child:type_ref '&' {
        new RefTypeRefNode(child)
    }
    / child:type_ref '*' {
        new PtrTypeRefNode(child)
    }
    / '#' '[' elementType:type_ref ']' {
        new ArrTypeRefNode(elementType)
    }
    / '#' '(' _ par:type_ref<0,,','> _ ')' _ ret:type_ref { 
        new FuncTypeRefNode(ret, par.ToList())
    }
    / '#' '(' _ inner:type_ref _ ')' { 
        inner
    }
    / named_type_ref

named_type_ref <NamedTypeRefNode>
    = nmspace2:(<NamespaceNode> nmspace:namespace? { nmspace.Count == 1 ? nmspace[0] : null })
    type:(<NamedTypeRefNode> '?' name:name { new LocalTypeRefNode(name, null) } / '#' name:name { new NamedTypeRefNode(name, null) }) {
        {
            type.Namespace = nmspace2;
            return type;
        }
    }

name <string> = [a-zA-Z_][a-zA-Z_0-9]*

literal_int <LiteralNode> = value:(<string> '-'? [0-9]+) { new LiteralNode(long.Parse(value)) }

literal_float <LiteralNode> = value:(<string> '-'? [0-9]+ '.' [0-9]+) { new LiteralNode(double.Parse(value)) }

_ = ws*

ws = [ \n\t]