@namespace Moth.AST
@classname MothParser
@accessibility public
@using Moth
@using Moth.AST.Node

script <ScriptAST> = nmspace:file_namespace statements:top_level* { new ScriptAST(nmspace, statements.ToList()) }

file_namespace <NamespaceNode> = "namespace" ws+ nmspace:namespace ';' { nmspace }

namespace <NamespaceNode> = "::" name:name child:namespace? { new NamespaceNode(name, child.Count == 1 ? child[0] : null) }

top_level <ITopDeclNode>
    = import
    / func_decl

import <ImportNode> = "with" ws+ nmspace:namespace ';' { new ImportNode(nmspace) }

method_decl <FuncDefNode> = isStatic:"static"? ws+ val:func_decl {
        {
            if (isStatic.Count > 0)
                val.IsStatic = true;
            
            return val;
        }
    }

func_decl <FuncDefNode>
    = attrs:attribute* ws+
    privacy:privacy ws+
    "func" ws+
    name:name _ '(' _ par:param<0,,','> _ ')' _
    ret:type_ref _
    scope:(<ScopeNode?> scope / ';' { null }) {
        //TODO: support variadics
        new FuncDefNode(name, privacy, ret, par.ToList(), scope, false, false, attrs.ToList())
    }

privacy <PrivacyType> = p:(<string> "priv" / "pub")? {
        p.Count == 1
            ? p[0] == "pub"
                ? PrivacyType.Pub
                : PrivacyType.Priv
            : PrivacyType.Priv
    }

param <ParameterNode> = name:name _ type:type_ref { new ParameterNode(name, type) }

scope <ScopeNode> = '{' statements:expression<0,,';'> '}' { new ScopeNode(statements.ToList()) }

expression <IExpressionNode> -memoize
    = scope
    / '(' _ inner:expression _ ')' {
        inner
    }
    / parent2:(<IExpressionNode> parent:expression _ '.' _ { parent })? name:name {
        new RefNode(name, parent2.Count == 1 ? parent2[0] : null)
    }
    / literal

//TODO: does this need to support complex expressions?
attribute <AttributeNode> = '@' name:name args2:(<IList<LiteralNode>> _ '(' _ args:literal<0,,','> _ ')' { args })? {
    new AttributeNode(name, args2.Count == 1 ? args2[0].ToList() : null)
}

//TODO: strings and chars and... scientific notation?
literal <LiteralNode>
    = literal_int
    / literal_float

//TODO: template type ref
type_ref <ITypeRefNode> -memoize
    = child:type_ref '&' {
        new RefTypeRefNode(child)
    }
    / child:type_ref '*' {
        new PtrTypeRefNode(child)
    }
    / '#' '[' elementType:type_ref ']' {
        new ArrTypeRefNode(elementType)
    }
    / '#' '(' _ par:type_ref<0,,','> _ ')' _ ret:type_ref { 
        new FuncTypeRefNode(ret, par.ToList())
    }
    / '#' '(' _ inner:type_ref _ ')' { 
        inner
    }
    / '?' name:name {
        new LocalTypeRefNode(name)
    }
    / '#' name:name {
        new NamedTypeRefNode(name)
    }

name <string> = [a-zA-Z_][a-zA-Z_0-9]*

literal_int <LiteralNode> = value:(<string> '-'? [0-9]+) { new LiteralNode(long.Parse(value)) }

literal_float <LiteralNode> = value:(<string> '-'? [0-9]+ '.' [0-9]+) { new LiteralNode(double.Parse(value)) }

_ = ws*

ws = [ \n\t]