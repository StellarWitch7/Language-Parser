namespace MothStd; // part of the standard libs

public func stdin() #File* {
    return #File.init(__acrt_iob_func(#u32 <- 0));
}

public func stdout() #File* {
    return #File.init(__acrt_iob_func(#u32 <- 1));
}

public func stderr() #File* {
    return #File.init(__acrt_iob_func(#u32 <- 2));
}

public func eof(ch #i32) #bool {
    return ch < 0;
}

public func write(char #char) #void {
    stdout().Write(char);
    return;
}

public func write(string #char*) #void {
    stdout().Write(string);
    return;
}

public func write(string #char*, end #char) #void {
    stdout().Write(string, end);
    return;
}

public func writeLine(string #char*) #void {
    stdout().WriteLine(string);
    return;
}

public func input(string #char*) #char* {
    return input(string, stdout(), stdin());
}

public func input(string #char*, output #File*, input #File*) #char* {
    output.Write(string, '\0');
    return input.ReadLine();
}

public func openFile(path #char*, mode #char*) #File* {
    return #File.init(fopen(path, mode));
}

public class File {
    public CFile #FILE*;

    public static func init(cfile #FILE*) #File* {
        self.CFile = cfile;
        return self;
    }

    public func Write(string #char*) #void {
        fputs(string, self.CFile);
        fflush(self.CFile);
        return;
    }

    public func Write(char #char) #void {
        local str #char* = #char* <- malloc(#u64 <- 1);
        sprintf(str, "%c", char);
        self.Write(str);
        return;
    }

    public func Write(string #char*, end #char) #void {
        self.Write(string)
        self.Write(end);
        return;
    }

    public func WriteLine(string #char*) #void {
        self.Write(string, '\n');
        return;
    }

    public func GetChar() #char {
        local ch #i32 = fgetc(self.CFile);

        if !eof(ch) {
            return #char <- ch;
        } else {
            return '\0';
        }
    }

    public func ReadLine() #char* {
        local size #u64 = #u64 <- 512;
        local string ?= #char* <- malloc(size);
        local ch #char;
        local len ?= -1;

        if string == null {
            return string;
        }

        while (ch = self.GetChar()) != '\0' and ch != '\n' {
            string[++len] = ch;
            
            if len >= (#i32 <- size) {
                string = #char* <- realloc(#void* <- string, size += (#u64 <- 512));

                if string == null {
                    return string;
                }
            }
        }

        string[++len] = '\0';
        string = #char* <- realloc(#void* <- string, #u64 <- ++len);
        return string;
    }
}

//public class Array<\T, SIZE #i32\> {
//    private value ?T*;
//
//    public static func init() #Array<\?T, SIZE\> {
//        self.value = malloc(SIZE * ?T.sizeof());
//        return self;
//    }
//
//    public func GetIndex(index #u32, val ?T**) #bool {
//        (load val) = if index > 0
//            and index < SIZE - 1
//            then self.value[index]
//            else null;
//        return if index > 0
//            and index < SIZE - 1
//            then true
//            else false;
//    }
//
//    public func SetIndex(index #u32, item ?T) #bool {
//
//        if index < 0 or index > SIZE - 1 {
//            return false;
//        }
//
//        self.value[index] = item;
//        return true;
//    }
//
//    public func AsPointer() ?T* {
//        return value;
//    }
//}